<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Systems Librarianship</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Entry level book on systems librarianship.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="p1-systems-librarianship.html"><strong aria-hidden="true">1.</strong> Systems Librarianship</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01-history-linux-unix.html"><strong aria-hidden="true">1.1.</strong> History of Unix and Linux</a></li><li class="chapter-item expanded "><a href="02-what-is-linux.html"><strong aria-hidden="true">1.2.</strong> What is Linux?</a></li><li class="chapter-item expanded "><a href="03-what-is-sysadmin.html"><strong aria-hidden="true">1.3.</strong> What is Systems Administration?</a></li><li class="chapter-item expanded "><a href="04-what-is-syslib.html"><strong aria-hidden="true">1.4.</strong> What is Systems Librarianship?</a></li></ol></li><li class="chapter-item expanded "><a href="p2-using-gcloud.html"><strong aria-hidden="true">2.</strong> Using Google Cloud (gcloud)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05-using-gcloud-virtual-machines.html"><strong aria-hidden="true">2.1.</strong> Using gcloud for Virtual Machines</a></li></ol></li><li class="chapter-item expanded "><a href="p3-learning-the-command-line.html"><strong aria-hidden="true">3.</strong> Learning the Command Line</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06-learn-the-cli.html"><strong aria-hidden="true">3.1.</strong> Learn the CLI</a></li><li class="chapter-item expanded "><a href="08-learn-nano.html"><strong aria-hidden="true">3.2.</strong> Using the Nano Text Editor</a></li><li class="chapter-item expanded "><a href="09-searching-with-grep.html"><strong aria-hidden="true">3.3.</strong> Searching with grep</a></li><li class="chapter-item expanded "><a href="10-managing-software.html"><strong aria-hidden="true">3.4.</strong> Managing Software</a></li></ol></li><li class="chapter-item expanded "><a href="p4-project-management.html"><strong aria-hidden="true">4.</strong> Project Management and Version Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="12-learn-git-and-github.html"><strong aria-hidden="true">4.1.</strong> Learn Git and GitHub</a></li><li class="chapter-item expanded "><a href="13-setup-git.html"><strong aria-hidden="true">4.2.</strong> Setup Git on Server</a></li></ol></li><li class="chapter-item expanded "><a href="p5-creating-a-lamp-server.html"><strong aria-hidden="true">5.</strong> Creating a LAMP Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="14-installing-the-apache-web-server.html"><strong aria-hidden="true">5.1.</strong> Installing the Apache Web Server</a></li><li class="chapter-item expanded "><a href="15-installing-configuring-php.html"><strong aria-hidden="true">5.2.</strong> Installing and Configuring PHP</a></li><li class="chapter-item expanded "><a href="16-installing-configuring-mysql.html"><strong aria-hidden="true">5.3.</strong> Installing and Configuring MariaDB</a></li></ol></li><li class="chapter-item expanded "><a href="p6-installing-content-management-systems.html"><strong aria-hidden="true">6.</strong> Installing Content Management Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="17-install-wordpress.html"><strong aria-hidden="true">6.1.</strong> Install Wordpress</a></li><li class="chapter-item expanded "><a href="18-install-omeka.html"><strong aria-hidden="true">6.2.</strong> Install Omeka</a></li><li class="chapter-item expanded "><a href="19-use-omeka.html"><strong aria-hidden="true">6.3.</strong> Use Omeka</a></li></ol></li><li class="chapter-item expanded "><a href="p7-installing-an-ILS.html"><strong aria-hidden="true">7.</strong> Installing an Integrated Library System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="20-install-koha.html"><strong aria-hidden="true">7.1.</strong> Install Koha</a></li><li class="chapter-item expanded "><a href="21-use-koha.html"><strong aria-hidden="true">7.2.</strong> Use Koha</a></li></ol></li><li class="chapter-item expanded "><a href="p8-conclusion.html"><strong aria-hidden="true">8.</strong> Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Systems Librarianship</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cseanburns/systems_librarianship" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="systems-librarianship"><a class="header" href="#systems-librarianship">Systems Librarianship</a></h1>
<p>Author: C. Sean Burns<br />
Date: 2023-01-03<br />
Email: <a href="sean.burns@uky.edu">sean.burns@uky.edu</a><br />
Website: <a href="https://cseanburns.net">cseanburns.net</a><br />
GitHub: <a href="https://github.com/cseanburns">@cseanburns</a></p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>This short book is a work in progress.
A main, first draft should be completed by
the end of April 2023.</p>
<p>I am writing this book as I teach
a course on Systems Librarianship.
The book and course's goals are 
to provide a technical introduction to
the basics of systems librarianship
using Linux.</p>
<p>The course and book goals include:</p>
<ol>
<li>how to use the Linux command line in order to become more
efficient computer users and more comfortable with using
computers in general;</li>
<li>how to use cloud computing resources and create virtual
machines;</li>
<li>how to manage projects using Git and GitHub;</li>
<li>how to create a LAMP server, websites, and create a
bare bones OPAC;</li>
<li>how to install and configure content management systems,
and;</li>
<li>how to install and configure an integrated library
system.</li>
</ol>
<h2 id="about-this-book"><a class="header" href="#about-this-book">About This Book</a></h2>
<p>The Systems Librarianship course is
a brand new course (2023).
I created the course to help future
and current librarians become proficient
in the kind of technology used to manage
and provide electronic resources.</p>
<p>Since I use this book for my
Systems Librarianship course,
which I hope to teach each spring semester,
this book will be a live document.
Each semester that I teach this course,
I will update the content in order
to address changes in the technology and to
edit for clarity when I discover some aspect
of the book causes confusion or
does not provide enough information.</p>
<p>A small part of this book will draw from
my course on
<a href="https://github.com/cseanburns/linux_sysadmin">Linux Systems Administration</a>,
which I teach in the fall semesters.</p>
<p>This book is not a
comprehensive introduction to
systems librarianship.
For example,
this book does not cover software coding nor
managerial duties, like issuing
requests for proposals for software products,
or budgeting.
It is designed as an entry level course in
the technical aspects of systems librarianship,
and it is meant to go hand-in-hand with 
other courses taught in our program.
That includes my course on
<a href="https://cseanburns.net/WWW/ERM-book/">electronic resource management</a>
but also other courses that my colleagues teach.</p>
<p>The book will start off as a series of transcripts, and
over time,
my hope is to build it out to a full fledged textbook
on systems librarianship.
I am using <a href="https://github.com/rust-lang/mdBook">mdBook</a> to build this work.</p>
<p>The content in this book is open access and
licensed under the <a href="https://github.com/cseanburns/systems_librarianship/blob/master/LICENSE">GNU GPL v3.0</a>.
Feel free to fork it on <a href="https://github.com/cseanburns/systems_librarianship">GitHub</a> and
modify it for your own needs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="history-of-unix-and-linux"><a class="header" href="#history-of-unix-and-linux">History of Unix and Linux</a></h1>
<p>An outline of the history of Unix and Linux.</p>
<h2 id="location-bell-labs-part-of-att-new-jersey-late-1960s-through-early-1970s"><a class="header" href="#location-bell-labs-part-of-att-new-jersey-late-1960s-through-early-1970s">Location: Bell Labs, part of AT&amp;T (New Jersey), late 1960s through early 1970s</a></h2>
<ul>
<li>Starts with an operating system called Multics.</li>
<li>Multics was a time sharing system
<ul>
<li>That is, more than one person could use it at once.</li>
</ul>
</li>
<li>But Multics had issues and was slowly abandoned</li>
<li><a href="http://cs.bell-labs.co/who/ken/">Ken Thompson</a> found an old PDP-7. Started to write UNIX.
<ul>
<li>The <a href="https://en.wikipedia.org/wiki/Ed_(text_editor)">ed</a> line editor was written.</li>
<li>Pronounced e.d. but generally sounded out.</li>
</ul>
</li>
<li>This version of UNIX would later be referred to as <em>Research Unix</em></li>
<li><a href="https://www.bell-labs.com/usr/dmr/www/">Dennis Ritchie</a>, the creator of the C programming language,
joined Thompson's efforts.</li>
</ul>
<h2 id="location-berkeley-ca-university-of-california-berkeley-early-to-mid-1970s"><a class="header" href="#location-berkeley-ca-university-of-california-berkeley-early-to-mid-1970s">Location: Berkeley, CA (University of California, Berkeley), early to mid 1970s</a></h2>
<ul>
<li>The code for UNIX was not 'free software'
but low cost and easily shared.</li>
<li>Ken Thompson visited Berkeley and helped install <a href="https://en.wikipedia.org/wiki/Berkeley_Software_Distribution">Version 6 of UNIX</a></li>
<li><a href="https://en.wikipedia.org/wiki/Bill_Joy">Bill Joy</a> and others contributed heavily
<ul>
<li>Joy created the <a href="https://sites.google.com/a/bostic.com/keithbostic/vi/">vi</a> text editor,
a descendant of the popular <a href="https://www.vim.org/">Vim</a> editor,
many other important programs, and was a co-founder of Sun Microsystems</li>
</ul>
</li>
<li>This installation of UNIX would eventually become known
as the Berkeley Software Distribution, or BSD.</li>
</ul>
<h2 id="att"><a class="header" href="#att">AT&amp;T</a></h2>
<ul>
<li>Until its breakup in 1984,
AT&amp;T was not allowed to profit off patents
that were not directly related to its telecommunications businesses.</li>
<li>This agreement with the US government helped
protect the company from monopolistic charges,
and as a result, they could not commercialize UNIX.</li>
<li>This changed after the breakup.
System V UNIX became the standard bearer of commercial UNIX.</li>
</ul>
<h2 id="location-boston-ma-mit-early-1980s-through-early-1990s"><a class="header" href="#location-boston-ma-mit-early-1980s-through-early-1990s">Location: Boston, MA (MIT), early 1980s through early 1990s</a></h2>
<ul>
<li>In the late 1970s, <a href="https://en.wikipedia.org/wiki/Richard_Stallman">Richard Stallman</a> noticed
that software began to become commercialized.
<ul>
<li>As a result, hardware vendors stopped sharing
the code they developed to make their hardware work.</li>
</ul>
</li>
<li>Software code became eligible for copyright protection with
the Copyright Act of 1976</li>
<li>Stallman, who thrived in a <em>hacker culture</em>,
began to battle against this turn of events.</li>
<li>Stallman created the <a href="https://www.gnu.org/gnu/gnu.html">GNU project</a>,
the free software philosophy, GNU Emacs,
a popular and important text editor,
and he wrote many other programs.</li>
<li>The GNU project is an attempt to create a completely
<strong>free software</strong> operating system,
that was Unix-like, called GNU.</li>
<li>By the early 1990s, Stallman and others had developed
all the utilities needed to have a full operating system,
except for a kernel, which they called <a href="https://www.gnu.org/software/hurd/">GNU Hurd</a>.</li>
<li>This included the Bash shell, written by <a href="https://opuslogica.com/">Brian Fox</a>.</li>
<li>The GNU philosophy includes several propositions
that define free software:</li>
</ul>
<blockquote>
<p>The four freedoms, per GNU Project:
0. The freedom to run the program as you wish,
for any purpose (freedom 0).</p>
<ol>
<li>The freedom to study how the program works,
and change it so it does your computing as you wish (freedom 1).
Access to the source code is a precondition for this.</li>
<li>The freedom to redistribute copies so you can help others (freedom 2).</li>
<li>The freedom to distribute copies of your modified
versions to others (freedom 3).
By doing this you can give the whole community a chance
to benefit from your changes.
Access to the source code is a precondition for this.</li>
</ol>
</blockquote>
<p><a href="https://www.gnu.org/philosophy/free-sw.html">The Four Freedoms</a></p>
<h2 id="the-unix-wars-and-the-lawsuit-late-1980s-through-the-early-1990s"><a class="header" href="#the-unix-wars-and-the-lawsuit-late-1980s-through-the-early-1990s">The Unix wars and the lawsuit, late 1980s through the early 1990s</a></h2>
<ul>
<li>AT&amp;T, after its breakup, began to commercialize Unix,
and differences in AT&amp;T Unix and BSD Unix arose.</li>
<li>The former was aimed at commercialization,
and the latter aimed at researchers and academics.</li>
<li>UNIX Systems Laboratories, Inc. (USL, part of AT&amp;T)
sued Berkeley Software Design, Inc.
(BSDi, part of the University of California, Berkeley)
for copyright and trademark violations.</li>
<li>USL ultimately lost the case,
but the lawsuit delayed adoption of BSD Unix.</li>
</ul>
<h2 id="linux-linus-torvalds-university-of-helsinki-finland-early-1990s"><a class="header" href="#linux-linus-torvalds-university-of-helsinki-finland-early-1990s">Linux, Linus Torvalds, University of Helsinki, Finland, early 1990s</a></h2>
<ul>
<li>On August 25, 1991, <a href="https://www.cs.helsinki.fi/u/torvalds/">Linus Torvalds</a>
announced that he had started working on a <strong>free</strong>
operating system kernel for the 386 CPU architecture
and for his specific hardware.</li>
<li>This <a href="https://www.kernel.org/">kernel</a> would later be named <strong>Linux</strong>.</li>
<li>Linux technically refers only to the kernel.
<ul>
<li>An operating system kernel handles startup,
devices, memory, resources, etc.</li>
<li>A kernel does not provide user land utilities---the
kinds of software they people use when using computers.</li>
</ul>
</li>
<li>Torvalds' motivation was to learn about OS development
but also to have access to a Unix-like system.
<ul>
<li>He already had access to an Unix-like system
called <a href="https://www.minix3.org/">MINIX</a>,
but MINIX had technical and copyright restrictions.</li>
</ul>
</li>
<li>Torvalds has stated that if a BSD or
if GNU Hurd operating system were available,
then he may not have created the Linux kernel.</li>
<li>But Torvalds and others took the GNU utilities
and created what is now called Linux or GNU/Linux.</li>
</ul>
<h2 id="distributions-early-1990s-through-today"><a class="header" href="#distributions-early-1990s-through-today">Distributions, early 1990s through today</a></h2>
<ul>
<li>Soon after the Linux development,
people would create their own Linux and
GNU based operating systems and would distribute them.</li>
<li>As such, these Linux operating systems became 
referred to as <em>distributions</em>.</li>
<li>The two oldest distributions that are still in 
active development include:
<ul>
<li><a href="http://www.slackware.com/">Slackware</a></li>
<li><a href="https://www.debian.org/">Debian</a></li>
</ul>
</li>
</ul>
<h2 id="short-history-of-bsd-1970s-through-today"><a class="header" href="#short-history-of-bsd-1970s-through-today">Short History of BSD, 1970s through today</a></h2>
<ul>
<li>Unix version numbers 1-6 eventually led to BSD 1-4.</li>
<li>At BSD 4.3, all versions had some AT&amp;T code.
<ul>
<li>Desire to remove this code led to BSD Net/1.</li>
</ul>
</li>
<li>All AT&amp;T code was removed by BSD Net/2.</li>
<li>BSD Net/2 was ported to the Intel 386 processor.
<ul>
<li>This became 386BSD and was made available in 1992,
a year after the Linux kernel was released.</li>
</ul>
</li>
<li>386BSD split into two projects:
<ul>
<li><a href="https://www.netbsd.org/">NetBSD</a></li>
<li><a href="https://www.freebsd.org/">FreeBSD</a></li>
</ul>
</li>
<li>NetBSD split into another project: <a href="https://www.openbsd.org/">OpenBSD</a>.</li>
<li>All three of these BSDs are still in active development.</li>
<li>From a bird's eye point of view, they each have different focuses:
<ul>
<li>NetBSD focuses on portability (MacOS, NASA)</li>
<li>FreeBSD focuses on wide applicability 
(WhatsApp, Netflix, PlayStation 4, MacOS)</li>
<li>OpenBSD focuses on security 
(has contributed a number of very important applications)</li>
</ul>
</li>
</ul>
<blockquote>
<p>MacOS is based on <a href="http://www.puredarwin.org/">Darwin</a>,
is <a href="https://www.opengroup.org/membership/forums/platform/unix">technically UNIX</a>, and is
partly based on FreeBSD with some code
coming from the other BSDs.
See <a href="https://apple.stackexchange.com/questions/401832/why-is-macos-often-referred-to-as-darwin">Why is macOS often referred to as 'Darwin'?</a>
for a short history.</p>
</blockquote>
<h2 id="short-history-of-gnu-1980s-through-today"><a class="header" href="#short-history-of-gnu-1980s-through-today">Short History of GNU, 1980s through today</a></h2>
<ul>
<li>The GNU Hurd is still under active development,
but it's the pre-production state.</li>
<li>The last release was 0.9 on December 2016.</li>
<li>A complete OS based on the GNU Hurd can be downloaded and ran.
For example: <a href="https://www.debian.org/ports/hurd/">Debian GNU/Hurd</a></li>
</ul>
<h2 id="free-and-open-source-licenses"><a class="header" href="#free-and-open-source-licenses">Free and Open Source Licenses</a></h2>
<p>In the free software and open source landscape,
there are several important free and/or open source
licenses that are used.
The two biggest software licenses are
based on the software used by GNU/Linux
and the software based on the BSDs.
They each take very different approaches to free
and/or open source software.
The biggest difference is this:</p>
<ul>
<li>Software based on software licensed under the GPL
must also be licensed under the GPL.
This is referred to as <a href="https://www.gnu.org/licenses/copyleft.en.html">copyleft</a> software,
and the idea is to propagate free software.
<ul>
<li><a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GNU General Public License (GPL)</a></li>
</ul>
</li>
<li>Software based on software licensed under the BSD
license may be closed source and
primarily must only attribute the original source code and author.
<ul>
<li><a href="https://opensource.org/licenses/BSD-3-Clause">BSD License</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-linux"><a class="header" href="#what-is-linux">What is Linux?</a></h1>
<h2 id="the-linux-kernel"><a class="header" href="#the-linux-kernel">The Linux Kernel</a></h2>
<p>Technically, <a href="https://kernel.org/">Linux is a kernel</a>, and
a kernel is a part of an operating system that
oversees CPU activity like multitasking, as well as networking,
memory management, device management, file systems, and more.
The kernel alone does not make an operating system.
It needs user land applications and programs,
the kind we use on a daily basis, to form a whole,
as well as ways for these user land utilities to
interact with the kernel.</p>
<h2 id="linux-and-gnu"><a class="header" href="#linux-and-gnu">Linux and GNU</a></h2>
<p>The earliest versions of the Linux kernel were combined
with tools, utilities, and programs from the <a href="https://www.gnu.org/software/software.html">GNU project</a>
to form a complete operating system,
without necessarily a graphical user interface.
This association continues to this day.
Additional non-GNU, but
free and open source programs under different licenses,
have been added to form a more functional and user friendly system.
However, since the Linux kernel needs user land applications
to form an operating system, and
since user land applications from GNU cannot work without a kernel,
some argue that the operating system
should be called <a href="https://en.wikipedia.org/wiki/GNU/Linux_naming_controversy">GNU/Linux</a>
and not just Linux.
This has not gained wide acceptance, though.
Regardless, credit is due to both camps for their contribution,
as well as many others who have made substantial contributions
to the operating system.</p>
<h2 id="linux-uses"><a class="header" href="#linux-uses">Linux Uses</a></h2>
<p>We are using Linux as a server in this course, which
means we will use Linux to provide various services.
Our first focus is to learn to use Linux itself, but
by the end of the course,
we will also learn how to provide web and database services.
Linux can be used to provide <a href="https://en.wikipedia.org/wiki/Server_(computing)">other services</a> that
we won't cover in this course, such as:</p>
<ul>
<li>file servers</li>
<li>mail servers</li>
<li>print servers</li>
<li>game servers</li>
<li>computing servers</li>
</ul>
<p>Although it's a small overall percentage,
many people use Linux as their main
desktop/laptop operating system.
I belong in this camp.
Linux has been my main OS since the early 2000s.
While our work on the Linux server means that we will
almost entirely work on the command line,
this does not mean that my Linux
desktop environment is all command line.
In fact, there are many graphical user environments,
often called <a href="https://en.wikipedia.org/wiki/Desktop_environment">desktop environments</a>,
available to Linux users.
Since I'm currently using the Ubuntu Desktop distribution,
my default desktop environment is called <a href="https://www.gnome.org/">Gnome</a>.
<a href="https://kde.org/">KDE</a> is another popular desktop environment, but
there are many other attractive and useful ones.
And it's easy to install and switch between
multiple ones on the same OS.</p>
<p>Linux has become quite a pervasive operating system.
Linux powers the hundreds of the
fastest supercomputers in the world.
It, or other Unix-like operating systems,
are the foundation of most web servers.
The Linux kernel also forms the basis of the Android
operating system and of Chrome OS.
The only place where Linux does not dominate is
in the desktop/laptop space.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-systems-administration"><a class="header" href="#what-is-systems-administration">What is Systems Administration?</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>What is systems administration or
who is a systems administrator (or <strong>sysadmin</strong>)?
Let's start off with some definitions provided by
the <a href="https://www.nist.gov/">National Institute of Standards and Technology</a>:</p>
<blockquote>
<p>An individual, group, or organization responsible for setting up and
maintaining a system or specific system elements, implements approved secure
baseline configurations, incorporates secure configuration settings for IT
products, and conducts/assists with configuration monitoring activities as
needed.</p>
</blockquote>
<p>Or:</p>
<blockquote>
<p>Individual or group responsible for overseeing the day-to-day operability of a
computer system or network. This position normally carries special privileges
including access to the protection state and software of a system.</p>
</blockquote>
<p>See: <a href="https://csrc.nist.gov/glossary/term/system_administrator">Systems Administrator @NIST</a></p>
<h2 id="specialized-positions"><a class="header" href="#specialized-positions">Specialized Positions</a></h2>
<p>In addition to the above definitions,
which broadly define the role,
there are a number of related or specialized positions.
We'll touch on the first three in this course:</p>
<ul>
<li>Web server administrator:
<ul>
<li>&quot;web server administrators are system architects responsible for the
overall design, implementation, and maintenance of Web servers. They may or
may not be responsible for Web content, which is traditionally the
responsibility of the Webmaster (<a href="https://csrc.nist.gov/glossary/term/web_server_administrator">Web Server Administrator&quot;
@NIST</a>).</li>
</ul>
</li>
<li>Database administrator:
<ul>
<li>like web admins, and to paraphrase above, database administrators are system
architects responsible for the overall design, implementation, and
maintenance of database management systems. </li>
</ul>
</li>
<li>Network administrator:
<ul>
<li>&quot;a person who manages a network within an organization. Responsibilities
include network security, installing new applications, distributing software
upgrades, monitoring daily activity, enforcing licensing agreements,
developing a storage management program, and providing for routine backups&quot;
(<a href="https://csrc.nist.gov/glossary/term/network_administrator">Network Administrator @NIST</a>).</li>
</ul>
</li>
<li>Mail server administrator:
<ul>
<li>&quot;mail server administrators are system architects responsible for the
overall design and implementation of mail servers&quot; (<a href="https://csrc.nist.gov/glossary/term/mail_server_administrator">Mail Server
Administrators @NIST</a>).</li>
</ul>
</li>
</ul>
<p>Depending on where a system administrator works,
they may specialize in any of the above administrative areas, or
if they work for a small organization,
all of the above duties may be rolled into one position.
Some of the positions have evolved quite a bit over the last
couple of decades.
For example, it wasn't too long ago when organizations would
operate their own mail servers, but
this has largely been outsourced to third-party providers,
such as Google (via Gmail) and Microsoft (via Outlook).
People are still needed to work with these
third-party email providers, but
the nature of the work is different than operating
independent mail servers.</p>
<h2 id="certifications"><a class="header" href="#certifications">Certifications</a></h2>
<p>It's not always necessary to get certified
as a systems administrator to get work as one, but
there might be cases where it is necessary; for example,
in government positions or in large corporations.
It also might be the case that you can get work
as an entry level systems administrator and
then pursue certification with
the support of your organization.</p>
<p>Some common starting certifications are:</p>
<ul>
<li><a href="https://www.redhat.com/en/services/certification/rhcsa">Red Hat Certified System Administrator (RHCSA)</a></li>
<li><a href="https://www.comptia.org/certifications/server">CompTIA Server+</a></li>
<li><a href="https://www.comptia.org/certifications/a">CompTIA A+</a></li>
</ul>
<p>Plus, Google offers, via <a href="https://www.coursera.org/">Coursera</a>, a
beginners <a href="https://www.coursera.org/professional-certificates/google-it-support">Google IT Support Professional Certificate</a>
that may be helpful.</p>
<h2 id="associations"><a class="header" href="#associations">Associations</a></h2>
<p>Getting involved in associations and related
organizations is a great way to learn and
to connect with others in the field.
Here are few ways to connect.</p>
<p><a href="https://lopsa.org/AboutLOPSA">LOPSA</a>, or
The League of Professional System Administrators,
is a non-profit association that seeks to advance
the field and membership is free for students.</p>
<p><a href="https://www.acm.org/">ACM</a>, or the Association for Computing Machinery,
has a number of relevant
<a href="https://www.acm.org/special-interest-groups/alphabetical-listing">special interest groups (SIGs)</a>
that might be beneficial to systems administrators. </p>
<p><a href="http://www.npa.org/">NPA</a>, or the Network Professional Association,
is an organization that &quot;supports IT/Network 
professionals.&quot;</p>
<h2 id="codes-of-ethics"><a class="header" href="#codes-of-ethics">Codes of Ethics</a></h2>
<p>Systems administrators manage computer systems
that contain a lot of data about us and
this raises privacy and competency issues,
which is why some have created code of ethics statements.
Both LOPSA and NPA have created such statements
that are well worth reviewing and discussing.</p>
<ul>
<li>LOPSA: <a href="https://lopsa.org/CodeOfEthics">Code of Ethics</a></li>
<li>NPA: <a href="https://www.npa.org/public/about_codeofethics.cfm">Code of Ethics</a></li>
</ul>
<h2 id="keeping-up"><a class="header" href="#keeping-up">Keeping Up</a></h2>
<p>Technology changes fast.
In fact, even though I teach this course
about every year,
I need to revise the
course each time, sometimes substantially,
to reflect changes that have developed
over short periods of time.
It's also your responsibility,
as sysadmins,
to keep up, too.</p>
<p>I therefore suggest that you continue your
education by reading and practicing.
For example, there are lots of books on 
systems administration.
<a href="https://www.npa.org/public/about_codeofethics.cfm">O'Reilly</a> continually
publishes on the topic.
RedHat,
the makers of the Red Hat Linux distribution,
and sponsors of <a href="https://www.linuxjournal.com/">Fedora Linux</a> and
<a href="https://centos.org/">CentOS Linux</a>,
provides the <a href="https://www.redhat.com/sysadmin/">Enable Sysadmin</a> site,
with new articles each day,
authored by systems administrators,
on the field.
Opensource.com, also supported by Red Hat,
<a href="https://opensource.com/tags/sysadmin">publishes articles on systems administration</a>.
<a href="https://www.redhat.com/en/command-line-heroes">Command Line Heroes</a> is a fun and
informative podcast on technology and
sysadmin related topics.
<a href="https://www.linuxjournal.com/">Linux Journal</a> publishes great articles
on Linux related topics.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this section I provided definitions of systems administrators
and also the related or more specialized positions,
such as database administrator, network administrator,
and others.</p>
<p>I provided links to various certifications you might
pursue as a systems administrator, and
links to associations that might benefit you and your career.</p>
<p>Technology manages so much of our daily lives, and
computer systems store lots of data about us.
Since systems administrators manage these systems,
they hold a great amount of responsibility
to protect them and our data.
Therefore, I provided links to two code of ethics
statements that we will discuss.</p>
<p>It's also important to keep up with the technology,
which changes fast.
The work of a systems administrator is much different
today than it was ten or twenty years ago, and
that surely indicates that it could be much different in
another ten to twenty years.
If we don't keep up,
we won't be of much use to the people we serve.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-systems-librarianship"><a class="header" href="#what-is-systems-librarianship">What is Systems Librarianship</a></h1>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>Of course, let's begin with the question,
what is systems librarianship?
Normally we might go to the literature
to answer a question like this.
Indeed, the literature is helpful,
but it's sparse.
The <a href="https://libguides.uky.edu/803">LISTA</a> database only
returns 131 results
with a 45 year coverage
for a search using the thesauri term
<strong>SYSTEMS Librarians</strong>.
I can get more results if I expand
the search query, but
then I get less relevant results, and
the main idea is the same:
this is an understudied area of
librarianship.</p>
<p>It's been that way for a while.
<a href="https://doi.org/10.1300/J111v09n04_06">Susan K. Martin</a>
wrote the following over 35 years ago:</p>
<blockquote>
<p>Of the specialist positions that exist in libraries, none
is as underexamined as those of the systems
librarians---the people who identify the needs of the
library for automated systems, cause these systems to be
implemented, and analyze the operations of the library (p.
57).</p>
</blockquote>
<p>Perhaps as a result of this
underexamination,
sometimes there is confusion around
the requirements and skills needed in
this area of librarianship.
Martin (1988) captured this tension
when she wrote the following in 1988,
which is still true today:</p>
<blockquote>
<p>Over the years the library world has argued whether
systems librarians should be librarians who have learned
information technologies, or computer experts who have
learned about libraries (p. 61).</p>
</blockquote>
<p>The argument is partly
a matter of jurisdiction.
<a href="https://www.proquest.com/docview/220452054/abstract/A48FC30B10D94886PQ/1?accountid=11836">Abbott (1998)</a>,
writing on librarianship in the sociology of professions,
illustrated how:</p>
<blockquote>
<p>The future of librarianship thus hinges on what happens to
the perpetually changing work of the profession in its
three contexts: the context of larger social and culture
forces, the context of other competing occupations, and
the context of competing organizations and commodities. To
these complex contextual forces, any profession responds
with varying policies and internal changes (pp. 434-5).</p>
</blockquote>
<p>Essentially, Abbott means that professions,
like librarianship,
are always changing.
The mechanisms for that change are
structural and cultural <a href="https://www.jstor.org/stable/40664150">(Abbott, 2010)</a>,
but a changing profession means that
its &quot;link of jurisdiction&quot;
(Abbott, 1998, p. 435) changes, too.
It not only changes, but
professions constantly compete with each
other over to adopt new areas
of jurisdiction.
So when we ask,
as Martin (1998) did,
whether librarians should learn
information technologies or whether
computer experts should learn libraries,
I find myself thinking the prior is
more important for libraries
and their patrons.
It means that librarians are expanding
their jurisdiction by also becoming
computer experts rather than
computer experts expanding theirs.</p>
<p>That leads us to the next questions:
what does it mean to be a computer
expert for a systems librarian?
What does a systems librarians need
to do and know?</p>
<p>The answer is that it is a mix.
Some part of the work involves
systems administration, but
that has broad meanings, and
systems librarianship is more specific.
Or, it has a more specific domain:
the domain of libraries and librarianship.</p>
<p>A systems librarian might thus be considered
a library systems administrator.
Under this view, they need to be someone
who knows about libraries,
how libraries work,
what they do,
about their patrons,
what their values are,
and then use that knowledge to build
the infrastructure to support that.</p>
<p>Given this, and the technologies involved,
such work requires constant learning.
<a href="https://doi.org/10.1108/07378830310494445">Jordan (2003)</a> 
identified three areas of learning:</p>
<ul>
<li>pre-service education in library schools</li>
<li>on the job training</li>
<li>professional development in the form of workshops,
courses, and conferences (p. 273)</li>
</ul>
<p>Pre-service, formal education is a small part
of any professional's career,
regardless if that profession is
in medicine, law, or librarianship.
Thus the goal of pre-service
education is to prepare people
to adapt and grow in their fields.
Jordan (2003) wrote that:</p>
<blockquote>
<p>While formal training is undoubtedly important, the
ability to learn new technologies independently lies at
the foundation of systems librarians' professional life,
because they often have to use technologies, or make
planning decisions about specific technologies, before
they become common enough to be the subject of formal
training sessions (p. 273).</p>
</blockquote>
<p>Even though Jordan's article
is 20 years old and
the technology has changed a lot,
the basic duties of the systems librarian
remain the same
(Fu, 2014; <a href="https://rowman.com/ISBN/9781538107133/Systems-Librarianship-A-Practical-Guide-for-Librarians">Gonzales, 2020</a>).
<a href="https://www.worldcat.org/title/1038159656">Wilson (1998)</a>,
as cited in Jordan (2003),
refers to a list of the
&quot;typical responsibilities of systems librarians.&quot;
These responsibilities look different today,
because the technology is different,
but conceptually,
they're the same as they were then.
In fact, this work will focus
on a subset of this list that includes:</p>
<ul>
<li>integrated library system management</li>
<li>server management</li>
<li>documentation</li>
<li>technology exploration and evaluation (Jordan, 2003, p. 274)</li>
</ul>
<p>Gonzales (2020) highlights these and
more current areas that include:</p>
<ul>
<li>content management systems</li>
<li>electronic resource management systems</li>
<li>website redesign</li>
<li>help and support</li>
</ul>
<p>Other items on Jordan's (2003) list are
still relevant, but
due to various constraints,
this work will not cover the following
areas:</p>
<ul>
<li>network design and management</li>
<li>desktop computing</li>
<li>application development</li>
<li>planning and budget</li>
<li>specification and purchasing</li>
<li>miscellaneous technology support</li>
<li>technical risk management (p. 274)</li>
</ul>
<p>In short,
this work specifically focuses on
a few of the bigger technical aspects of
systems librarianship.
Other works (or courses) and
other sources will provide learning
opportunities on the more
managerial and administrative functions
of systems librarianship and librarianship, in general.</p>
<blockquote>
<p>If you are interested in learning
more about network design and administration,
then I encourage you to read my chapters on
<a href="https://cseanburns.net/WWW/linux-systems-admin/19-networking-tcpip.html">Networking and TCP/IP</a> and
<a href="https://cseanburns.net/WWW/linux-systems-admin/20-dns-domain-names.html">DNS and Domain Names</a> in my
book on
<a href="https://cseanburns.net/WWW/linux-systems-admin/">Systems Administration with Linux</a>.</p>
<p>If you are interested in learning about
application development,
then you can pursue courses in a variety
of programming languages,
such as R, Python, JavaScript, and PHP,
as well as courses on relational databases,
such as MySQL or PostgreSQL, and so forth.</p>
</blockquote>
<p>As Jordan (2003) identified,
there is a lack of formalized training
in systems librarianship in LIS schools.
This is as true today as it was in 2003.
This course was created to address the
lack of that training.
However, it can only be a start.
Technology is constantly changing, and
that means we must always embrace more
informal learning opportunities.
LIS programs are only two or so years
long (if attending full time), but
our careers, hopefully, will span decades.
So all this course can ever be
is just a starting point.</p>
<p>It is a big start, though.
This course should lay a strong foundation for
self-growth and self-education
in the variety of technologies
that we will learn and use here.
Although separate areas of librarianship,
my work (and course) on
<a href="https://cseanburns.net/WWW/ERM-book/">electronic resource management</a>
complement this one in many ways.
For example, this work supports several
parts of the technology section in the
<a href="https://www.nasig.org/Competencies-Eresources">NASIG Core Competencies for Electronic Resources
Librarians</a>.
It is no coincidence these two areas of
librarianship often overlap or are
assumed in a single librarian position.</p>
<h2 id="cloud-computing"><a class="header" href="#cloud-computing">Cloud Computing</a></h2>
<p>Lastly, I want to mention cloud computing.
This has become a major area of change in
the last decade or so.
It used to be more common for librarians
to install their integrated library system software
and store their bibliographic data on their premises.
In the last ten years,
there has been more migration to the cloud,
which means that both the integrated library system
software and the bibliographic data are stored off-site.
<a href="https://doi.org/10.1108/10650751311294528">Liu &amp; Cai (2013)</a> highlight the beginning
of this trend toward cloud computing
that continues to play a large role in
systems librarianship <a href="https://doi.org/10.1108/DLP-03-2021-0022">(Naveed et al., 2021)</a>.
As Liu and Cai note:</p>
<blockquote>
<p>Systems librarians used to make their livings by managing
hosted library systems. This situation is silently
changing with the library systems moving onto the cloud
(p. 26).</p>
</blockquote>
<p>This trend has changed some aspects of
systems librarianship.
It means that systems librarians,
while still a technical area of librarianship,
need to work more closely with the vendors
who themselves are hosting library systems.
However, the trend does not erase all
locally hosted solutions.
Many libraries and other information agencies
continue to support local collections and
will either host those locally or work
to get the bibliographic information for those
collections ingested into their cloud-based
integrated library systems.</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>The remainder of the course
will be more technical and
will prepare you to work and understand the
systems that support the modern library.
We will cover a lot, too!
We will begin with setting up
virtual machine instances on Google Cloud.
We will use a distribution of the Linux
operating system for these virtual machines.
We will then learn the basics of the
Linux command line.
Next, we will learn how to use
the version control system called <code>git</code>.
We will use <code>git</code> to document our work flows and
push that documentation to <a href="https://github.com">GitHub.com</a>.
On our Linux servers,
we will create a web server out of
what is called a LAMP stack,
which stands for
Linux, Apache, MySQL, and PHP.
We will use the web server
to setup a basic website and
a bare bones OPAC.
(I'll provide the code for this.)
Then we will learn how to install
and setup two content management systems:
Wordpress and Omeka.
Lastly, we will spend the final
two weeks of the semester
installing and setting up the
open source <a href="https://koha-community.org/">Koha ILS</a>.</p>
<p>Let's get started!</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>Abbott, A. (1998). Professionalism and the future of
librarianship. Library Trends, 46(3), 430–443.
<a href="https://www.proquest.com/docview/220452054/abstract/A48FC30B10D94886PQ/1?accountid=11836">https://www.proquest.com/docview/220452054/abstract/A48FC30B10D94886PQ/1?accountid=11836</a></p>
<p>Abbott, A. (2010). Varieties of ignorance. <em>The American
Sociologist, 41</em>(2), 174–189.
<a href="https://www.jstor.org/stable/40664150">https://www.jstor.org/stable/40664150</a></p>
<p>Gonzales, B. M. (2020). Systems librarianship: A practical
guide for librarians. Rowman &amp; Littlefield Publishers.
<a href="https://rowman.com/ISBN/9781538107133/Systems-Librarianship-A-Practical-Guide-for-Librarians">https://rowman.com/ISBN/9781538107133/Systems-Librarianship-A-Practical-Guide-for-Librarians</a></p>
<p>Fu, P. (2014). Supporting the next-generation ILS: The
changing roles of systems librarians. <em>Journal of Library
Innovation, 5</em>(1), 30–42.</p>
<p>Jordan, M. (2003). The self‐education of systems librarians.
Library Hi Tech, 21(3), 273–279.
<a href="https://doi.org/10.1108/07378830310494445">https://doi.org/10.1108/07378830310494445</a></p>
<p>Liu, W., &amp; Cai, H. (Heather). (2013). Embracing the shift to
cloud computing: Knowledge and skills for systems
librarians. OCLC Systems &amp; Services: International Digital
Library Perspectives, 29(1), 22–29.
<a href="https://doi.org/10.1108/10650751311294528">https://doi.org/10.1108/10650751311294528</a></p>
<p>Martin, S. K. (1988). The role of the systems librarian.
<em>Journal of Library Administration, 9</em>(4), 57–68.
<a href="https://doi.org/10.1300/J111v09n04_06">https://doi.org/10.1300/J111v09n04_06</a></p>
<p>Naveed, M. A., Siddique, N., &amp; Mahmood, K. (2021).
Development and validation of core technology competencies
for systems librarian. <em>Digital Library Perspectives, 38</em>(2),
189–204.
<a href="https://doi.org/10.1108/DLP-03-2021-0022">https://doi.org/10.1108/DLP-03-2021-0022</a></p>
<p>Ratledge, D., &amp; Sproles, C. (2017). An analysis of the
changing role of systems librarians. Library Hi Tech, 35(2),
303–311.
<a href="https://doi.org/10.1108/LHT-08-2016-0092">https://doi.org/10.1108/LHT-08-2016-0092</a></p>
<p>Wilson, T. C. (1998). Systems librarian: Desinging roles,
defining skills. American Library Association.
<a href="https://www.worldcat.org/title/1038159656">https://www.worldcat.org/title/1038159656</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-google-cloud-gcloud"><a class="header" href="#using-google-cloud-gcloud">Using Google Cloud (gcloud)</a></h1>
<p>This section introduces us to <a href="https://cloud.google.com">Google Cloud</a> (gcloud).
We will use this platform to create virtual
instances of the Ubuntu Server Linux operating system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-gcloud-for-virtual-machines"><a class="header" href="#using-gcloud-for-virtual-machines">Using gcloud for Virtual Machines</a></h1>
<h2 id="virtual-machines"><a class="header" href="#virtual-machines">Virtual Machines</a></h2>
<p>Our goal in this section 
is to create a <strong>virtual machine (VM)</strong> <em>instance</em>.
A VM is basically a virtualized operating system
that runs on a host operating system.
That host operating system may also be Linux,
but it could be Windows or macOS.
In short,
when we use virtual machines,
it means instead of installing an operating system
(like Linux, macOS, Windows, etc) on a physical machine,
we use virtual machine software to mimic the process.
The virtual machine, thus, runs on top of our main OS.
It's like an app, where the app is a fully functioning
operating system.</p>
<p>In my Linux Systems Administration course,
we used to use <a href="https://www.virtualbox.org/">VirtualBox</a> to create
virtual machines with Linux as the virtual operating system.
This worked despite whether you or I were running
Windows, macOS, or Linux as our main operating systems.
VirtualBox is freely available virtualization software,
and using it let students and myself
run Linux as a server
on our own desktops and laptops without changing
the underlying OS on those machines
(e.g., Windows, macOS).</p>
<p>However, even though we virtualize an operating
system when we run a VM,
the underlying operating system and CPU architecture
are still important.
When Apple, Inc launched their new M1 
(ARM-based) chip in 2020,
it created problems for running non ARM-based operating
systems as virtual machines (i.e., x86_64 chips).</p>
<p>Fortunately, we are able to solve that issue
using a third-party virtualization platform.
In this course,
that means we're going to use gcloud (via Google).
There are other options available that you 
can explore on your own.</p>
<h2 id="google-cloud--gcloud"><a class="header" href="#google-cloud--gcloud">Google Cloud / gcloud</a></h2>
<h3 id="google-account"><a class="header" href="#google-account">Google Account</a></h3>
<p>We need to have a personal Google
account to get started with gcloud.
I imagine most of you already have a Google account,
but if not, go ahead and create one at
<a href="https://www.google.com">https://www.google.com</a>.</p>
<h3 id="google-cloud-gcloud-project"><a class="header" href="#google-cloud-gcloud-project">Google Cloud (gcloud) Project</a></h3>
<p>Next, the gcloud software
helps you us on a Google Cloud project
on your own system.
Once you've created that project,
you can enable billing for that project,
and then install the gcloud software 
on your local machine.</p>
<p>Follow <strong>Step 1</strong> at the top of the 
<strong><a href="https://cloud.google.com/sdk/docs/install-sdk">Install the gcloud CLI</a></strong> page
to create a new project.
Also, review the page on
<a href="https://cloud.google.com/resource-manager/docs/creating-managing-projects#gcloud">creating and managing projects</a>.</p>
<p>When you create your project,
you can name it anything,
but try to name it something to do with this course.
E.g., I am using the name <strong>syslib-2023</strong>.
Avoid using spaces when naming your project.</p>
<p>Then click on the <strong>Create</strong> button,
and leave the organization field
set to <strong>No Organization</strong>.</p>
<h3 id="google-billing"><a class="header" href="#google-billing">Google Billing</a></h3>
<p>The second thing to do is to set up
a billing account for your gcloud project.
This does mean there is a cost associated
with this product, but
the good news is that our bills by the end of the semester should
only amount to $5 to 10 dollars, at most.
<strong><a href="https://cloud.google.com/sdk/docs/install-sdk">Follow Step 2</a></strong> to enable
billing for your new project.
See also the page on how to
<strong><a href="https://cloud.google.com/billing/docs/how-to/manage-billing-account">create, modify, or close your self-serve Cloud Billing account</a></strong></p>
<h3 id="install-the-latest-gcloud-cli-version"><a class="header" href="#install-the-latest-gcloud-cli-version">Install the latest gcloud CLI version</a></h3>
<p>After you have set up billing,
the next step is to install gcloud on your local machines. 
The <strong><a href="https://cloud.google.com/sdk/docs/install-sdk">Install the gcloud CLI</a></strong> page
provides instructions for different operating systems.</p>
<p>There are installation instructions
for macOS, Windows, Chromebooks, and various Linux distributions.
Follow these instructions closely for the operating system
that you're using.
Note that for macOS,
you have to choose among three different CPU/chip
architectures.
If you have an older macOS machine (before November 2020 or so),
it's likely that you'll select <strong>macOS 64-bit (x86_64)</strong>.
If you have a newer macOS machine,
then it's likely you'll have to select <strong>macOS 64-bit (arm64, Apple M1
silicon).</strong>
It's unlikely that any of you are using a 32-bit macOS operating system.
If you're not sure which macOS system you have,
then let me know and I can help you determine the appropriate platform.
Alternatively, follow these instructions to find your processor information:</p>
<ul>
<li>click on the Apple menu</li>
<li>choose <strong>About This Mac</strong></li>
<li>locate the <strong>Processor</strong> or <strong>Chip</strong> information</li>
</ul>
<p>After you have downloaded the gcloud CLI
for your particular OS and CPU architecture,
you will need to open a command prompt/terminal
on your machines to complete the instructions
that describe how to install the gcloud CLI.
macOS uses the Terminal app,
which can located using Spotlight.
Windows user can use Command.exe,
which can be located by search also.</p>
<p>Windows users will download a regular <strong>.exe</strong> file,
but macOS users will download a <strong>.tar.gz</strong> file.
Since macOS is Unix, you can use the <code>mv</code> command to 
move that file to your <code>$HOME</code> directory.
Then you extract it there using the <code>tar</code> command,
and once extracted
you can change to the directory that it
creates with the <code>cd</code> command.
For example, if you are downloading the X86_64 version
of the gcloud CLI, then you would run the following commands:</p>
<p>For macOS users, this assumes the <strong>.tar.gz</strong> file
was downloaded to your default Downloads folder:</p>
<pre><code>cd ~/Downloads/
mv google-cloud-cli-392.0.0-darwin-x86_64.tar.gz ~/
cd ~/
tar -xzf google-cloud-cli-392.0.0-darwin-x86_64.tar.gz
cd google-cloud-sdk
</code></pre>
<p>Modify the above commands, as appropriate,
if you're using the M1 or the M2 version
of the gcloud CLI.</p>
<h3 id="initializing-the-gcloud-cli"><a class="header" href="#initializing-the-gcloud-cli">Initializing the gcloud CLI</a></h3>
<p><strong>Please follow the instructions
from the Google Cloud documentation
for your operating system.</strong></p>
<p>Once you have downloaded and installed
the gcloud CLI program,
you need to initialize it on your local machine.
Scroll down on the <a href="https://cloud.google.com/sdk/docs/install-sdk">install page</a>
to the section titled
<strong>Initializing the gcloud CLI</strong>.
In your terminal/command prompt,
run the initialization command,
per the instructions at the above page:</p>
<pre><code>gcloud init
</code></pre>
<p>And continue to follow the above instructions.</p>
<h2 id="gcloud-vm-instance"><a class="header" href="#gcloud-vm-instance">gcloud VM Instance</a></h2>
<p>Once you've initialized gcloud,
log into <a href="https://console.cloud.google.com/">Google Cloud Console</a>,
which should take you to the Dashboard page.</p>
<p>Our first goal is to create a <strong>virtual machine (VM)</strong> <em>instance</em>.
As a reminder,
a VM is basically a virtualized operating system.
That means instead of installing an operating system
(like Linux, macOS, Windows, etc) on a physical machine,
software is used to mimic the process. </p>
<p>gcloud offers a number of Linux-based operating systems
to create VMs.
We're going to use the Ubuntu operating system
and specifically the Ubuntu 20.04 LTS version.</p>
<blockquote>
<p>Ubuntu is a Linux distribution.
There are many, many distributions of Linux, and
most are probably listed on the <a href="https://distrowatch.com/">DistroWatch</a> site.
A new version of Ubuntu is released every six months.
The 20.04 signifies that this is the April 2020 version.
LTS signifies <strong>Long Term Support</strong>.
LTS versions are released every two years,
and Canonical LTD,
the owners of Ubuntu,
provide standard support for LTS versions for five years.</p>
<p>LTS versions of Ubuntu are stable.
Non-LTS versions of Ubuntu receive nine months of standard support,
and generally apply cutting edge technology,
which is not always desirable for server operating systems.
Each version of Ubuntu has a code name.
20.04 has the code name <strong>Focal Fossa</strong>.
You can see a list of versions, code names, release dates,
and more on Ubuntu's <a href="https://wiki.ubuntu.com/Releases">Releases</a> page.</p>
</blockquote>
<p>We will create our VM using the gcloud console.
To do so, follow these steps from the Project page:</p>
<ul>
<li>Click on the hamburger icon (three vertical bars) in the
top right corner.</li>
<li>Click on <strong>Compute Engine</strong> and then <strong>VM instances</strong></li>
<li>Make sure your project is listed.</li>
<li>Next, click on <strong>Create Instance</strong>.</li>
<li>Provide a name for your <strong>instance</strong>.
<ul>
<li>E.g., I chose <strong>syslib-2023</strong> (no spaces) </li>
</ul>
</li>
<li>Under the <strong>Series</strong> drop down box, make sure <strong>E2</strong> is selected.</li>
<li>Under the <strong>Machine type</strong> drop down box, select <strong>e2-micro (2 vCPU, 1 GB memory)</strong>
<ul>
<li>This is the lowest cost virtual machine and perfect for our needs.</li>
</ul>
</li>
<li>Under <strong>Boot disk</strong>, click on the <strong>Change</strong> button.</li>
<li>In the window, select <strong>Ubuntu</strong> from the <strong>Operating system</strong> drop down box.</li>
<li>Select <strong>Ubuntu 20.04 LTS x86/64</strong></li>
<li>Leave <strong>Boot disk type</strong> be set to <strong>Balanced persistent disk</strong></li>
<li>Disk size should be set to <strong>10 GB</strong>.</li>
<li>Click on the <strong>Select</strong> button.</li>
<li>Check the <strong>Allow HTTP Traffic</strong> button</li>
<li>Finally, click on the <strong>Create</strong> button to create your VM instance.</li>
</ul>
<blockquote>
<p>Later in the semester when we install Koha, we will need
to create a virtual machine with more CPUs and memory.
We will be charged more for those machines.
Since we do not yet need the extra resources,
we will start off with fairly low powered
machines.</p>
</blockquote>
<h2 id="connect-to-our-vm"><a class="header" href="#connect-to-our-vm">Connect to our VM</a></h2>
<p>After the new VM machine has been created,
we need to connect to it via the command line.
macOS users will connect to it via their Terminal.app.
Windows users can connect to it via their command prompt.</p>
<p>We use a <code>ssh</code> command
to connect to our VMs.
The syntax follows this pattern:</p>
<pre><code>gcloud compute ssh --zone &quot;zone-info&quot; &quot;name-info&quot; --project &quot;project-id&quot;
</code></pre>
<p>The values in the double quotes in the above command
can be located in your Google Cloud console and
in your VM instances section.
See the course video for details.</p>
<h2 id="update-our-ubuntu-vm"><a class="header" href="#update-our-ubuntu-vm">Update our Ubuntu VM</a></h2>
<p>The VM will include a recently updated version of Ubuntu 20.04,
but it may not be completely updated.
Thus the first thing we need to do is update our machines.
On Ubuntu, we'll use the following two commands,
which you should run also:</p>
<pre><code>sudo apt update
sudo apt -y upgrade
</code></pre>
<p>Then type <code>exit</code> to logout and quit the connection to the remote server.</p>
<pre><code>exit
</code></pre>
<blockquote>
<p>When you log into your machines, you'll note a command
prompt that ends with a dollar sign <code>$</code>. This is where
we type our commands. The command prompt also displays our
location in the file system. The tilde <code>~</code> is a
shorthand symbol for our home directory. By default, we
are placed in our home directory whenever we login to our
machines.</p>
</blockquote>
<h2 id="snapshots"><a class="header" href="#snapshots">Snapshots</a></h2>
<p>Lastly, we have installed a pristine version of Ubuntu,
but it's likely that we will mess something up 
as we work on our systems.
Or it could be that our systems may become compromised
at some point.
Therefore, we want to create a snapshot of our newly
installed Ubuntu server.
This will allow us to restore our server if something
goes wrong later.</p>
<p>To get started:</p>
<ol>
<li>
<p>In the left hand navigation panel, click on <strong>Snapshots</strong>.</p>
</li>
<li>
<p>At the top of the page, click on <strong>Create Snapshot</strong>.</p>
</li>
<li>
<p>Provide a name for your snapshot: e.g., <strong>ubuntu-1</strong>.</p>
</li>
<li>
<p>Provide a description of your snapshot: e.g.,</p>
<p>This is a new install of Ubuntu 20.04.</p>
</li>
<li>
<p>Choose your <strong>Source disk</strong>.</p>
</li>
<li>
<p>Choose a <strong>Location</strong> to store your snapshot.</p>
<ul>
<li>To avoid extra charges, choose <strong>Regional</strong>.</li>
<li>From the drop down box, select the same location (zone-info) your VM has</li>
</ul>
</li>
<li>
<p>Click on <strong>Create</strong></p>
</li>
</ol>
<p><strong><p style="color:red">Please monitor your billing for this to avoid costs
that you do not want to incur.</p></strong></p>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>Congratulations!
You have just completed your first installation of a Linux server.</p>
<p>To summarize,
in this section,
you learned about and created a VM with gcloud.
This is a lot! 
After this course is completed,
you will be able to fire up a virtual machine
on short notice and deploy websites and more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-the-command-line"><a class="header" href="#learning-the-command-line">Learning the Command Line</a></h1>
<p>It's obviously more common for people today
to learn how to use a computer via a 
graphical user interface (GUI), but
there are benefits to learning a
command line interface (CLI).
In this section,
we learn some of the basics
of using the <a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">Bash shell</a> as our CLI.
Our primary goal is to learn how
to use the CLI as a file manager and
to perform some text editing.
However, if you find this interface appealing,
know that Bash is a
<a href="https://www.redhat.com/sysadmin/learn-bash-scripting">full-fledged programming language</a>, and
I encourage you to explore it as a scripting language.</p>
<p>There are three reasons,
from a systems administration point of view,
to prefer the CLI over the GUI.
First, the GUI entails extra software, and
the more software we have on a server,
the more resources (memory, CPU, storage, etc)
that software consumes.
We would much rather have our machine's
resources being used to provide the services
we build them to do than to run irrelevant software.
Second, the extra software a GUI requires means
that we expose our systems to additional security risks.
That is, every time we install more software
on our servers,
the server becomes more vulnerable
because all software has bugs.
This means that we want to be
conservative, careful, and protective
of our systems.
This is especially true for production systems.
Third, graphical user interfaces do not provide
a good platform for automation,
at least not remotely as well 
as command line interfaces do.
Working on the command line,
becuase it is a text-based environment,
in what is known as a <a href="https://en.wikipedia.org/wiki/Unix_shell">shell</a>,
is a reproducible process.
That is not as easily true in a GUI.</p>
<p>Fortunately, Linux, and
many other Unix-like operating systems,
have the ability to operate without graphical user interfaces.
This is partly the reason why these operating systems
have done so well in the server market.</p>
<p>In this section,
our focus is learning the command line environment.
We will do this using the Bash shell.
We will learn how to use the shell,
how to navigate around the filesystem,
how to perform basic tasks, and
explore other functions and utilities
the shell has to offer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learn-the-command-line-interface-cli"><a class="header" href="#learn-the-command-line-interface-cli">Learn the Command Line Interface (CLI)</a></h1>
<h2 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h2>
<p>There are two major interfaces
that we use to interact with our computers.
The most common interface is the 
graphical user interface, or GUI.
This interface largely emphasizes
non-textual interaction,
such as the mouse, fingers (touch screens),
remote controls (e.g., smart TVs),
and most recently,
wearable tech such as
VR headsets and like.
All of the above mechanisms for interacting
with our computer systems are worthwhile, but
more importantly, they are all suited to
specific ranges of engagement with our computers.
That is,
<a href="https://doi.org/10.7551/mitpress/7221.001.0001">they <em>afford</em> certain kinds of actions</a>
(Dourish, 2001).</p>
<p>The other major way of interfacing with
our computers is via the
command line interface, or CLI.
The CLI is also suited to
specific ranges of engagement, and
its the kind of engagement that often
allows us greater control over our systems.</p>
<p>One reason the CLI provides greater
control over our systems is because
the interaction is all text-based.
Text-based interaction requires more
specificity than graphical-based interaction.
By that I mean, it requires us to provide
written instructions to a computer and
to know what instructions to give it
when we want the computer to perform
some specific action.
This means that we have to memorize
some common instructions in order to
use our systems.
This is not necessarily difficult because
many of the most common instructions,
or <em>commands</em>,
are mnemonic, but
it does take some getting used to.</p>
<p>A second reason the CLI provides greater
control over the system is that because
it's text-based,
it can be automated.
We will not cover programming
in this work or course,
but know that all the commands
that we will learn can be put
in a text file,
made into an executable file,
and run like a program.
This makes text-based interaction
rather powerful.</p>
<h2 id="basic-commands"><a class="header" href="#basic-commands">Basic Commands</a></h2>
<p>In light of that,
I have developed two programs that
will help you remember these basic
commands.
The commands that I'll ask you to
learn encompass less than 0.3%
of the commands that are available
on a Linux system, but
they are the most commonly used commands.
Many of the other commands that are
available are for very specific purposes.
I'd estimate
that despite having used the Linux
command line for over 20 years,
I've barely used 20% of them, and
I might be stretching my estimate.</p>
<p>The first set of commands that
I'll ask you to learn and
practice include the following:</p>
<pre><code>list files and directories.................. ls
print name of current/working directory..... pwd
create a new directory...................... mkdir
remove or delete an empty directory......... rmdir
change directory............................ cd
create an empty file........................ touch
print characters to output.................. echo
display contents of a text file............. cat
copy a file or directory.................... cp
move or rename a file or directory.......... mv
remove or delete a file or directory........ rm
</code></pre>
<p>You will practice these commands using
the program that I wrote
called <a href="https://github.com/cseanburns/learn-the-commandline/blob/main/learn-the-cli">learn-the-cli</a>
(I will show you how to install
this and the other programs shortly).</p>
<p>I also developed a <a href="https://github.com/cseanburns/learn-the-commandline/blob/main/flashcards">flashcards</a>
program that will help you learn an
additional fifteen commands.
This program is based on one created
by someone else for a different purpose
(see source code link above for credit).
I'll explain these additional commands
as we proceed through the semester.
In the meantime,
I'll ask that you periodically run
the <code>flashcards</code> program to
familiarize yourself with these commands,
which includes the ones in the list above
but also a few additional ones.</p>
<h2 id="the-filesystem"><a class="header" href="#the-filesystem">The Filesystem</a></h2>
<p>In addition to the various commands
that I'll ask you to learn,
you will also have to learn the
structure of the Linux filesystem.
A filesystem has several meanings, but
in this context,
I refer to where the directories
on the Linux system are placed.
I find this to be the most difficult
thing that new Linux users have to learn
for a couple of reasons.
First, modern operating systems tend
to hide the filesystem from their users.
So even though, for example,
macOS is Unix,
many macOS users that I have taught
are completely unfamiliar with the
layout of directories on their system.
This is because,
per my observations,
macOS Finder does not show
the filesytem by default these days.
Instead it shows its users some common
locations for <strong>folders</strong>.
This might make macOS more usable to
most users, but
it makes learning the system more difficult.</p>
<p>What's common for both macOS and Linux
operating systems is a filesytem based on a
tree-like structure.
These filesystems begin at what's called a
<strong>root</strong> location.
The <strong>root</strong> location is referenced by
a forward slash: <code>/</code>.
All directories <strong>branch</strong> off from root.
The location to any directory is called
a <strong>PATH</strong>.
For example, our home directories on
Linux will be located at the following PATH:</p>
<pre><code>/home
</code></pre>
<p>That PATH begins at root <code>/</code> and ends at <code>home</code>.</p>
<p>It is a little different for Windows users.
Since Windows is not Unix-like,
it uses a different filesystem hierarchy.
Many Windows users might be familiar with
the basics, such as the <strong>C:</strong> drive for the
main storage device or the <strong>D:</strong> drive for
an added USB stick.
As such, the Windows operating system
uses multiple root directories (C:, D:, E:, etc.)
I encourage you to read the following article on
<a href="https://www.redhat.com/sysadmin/linux-filesystem-windows">A quick introduction to the Linux filesystem for Windows users</a>.
The article is published by <em>Red Hat</em>,
which makes its own Linux distribution.</p>
<p>In short, learning the Linux filesystem
requires adopting a new mental model
about how the operating system organizes
its directories and files.
Like learning the basic commands,
it's not too hard,
but it may take time and practice
before it sticks.
To help learn it,
I wrote an additional program that
will let you practice navigating around
the Linux filesystem and making some
changes to it.
The program is called
<a href="https://github.com/cseanburns/learn-the-commandline/blob/main/learn-the-filesystem">learn-the-filesystem</a>.
Before you use this program,
I would like to encourage you to read
another <em>Red Hat</em> article on
<a href="https://www.redhat.com/sysadmin/navigating-filesystem-linux-terminal">Navigating your filesystem in the Linux terminal</a>.
It includes sections that my program will cover
that include:</p>
<ul>
<li>viewing file lists</li>
<li>opening a folder (aka, a directory)</li>
<li>closing a folder</li>
<li>navigating directories</li>
<li>absolute paths</li>
</ul>
<h2 id="bash-the-bourne-again-shell"><a class="header" href="#bash-the-bourne-again-shell">Bash: The Bourne Again Shell</a></h2>
<p>I should point out that the
command line interface that we
are using on our Linux servers
is provided by a <a href="https://en.wikipedia.org/wiki/Unix_shell">shell</a>.
A shell is &quot;both an interactive
command language and a scripting
language&quot; (see link above).
We will use the shell strictly
as a <a href="https://en.wikipedia.org/wiki/Command_language">command language</a>,
but if you're interested someday,
I'd encourage you to explore Bash
as a <a href="https://en.wikipedia.org/wiki/Scripting_language">scripting language</a>
(I personally script in Bash quite a lot).
There are a variety of shells
available for Linux and other Unix-like
operating systems, but
the most popular one and
the one we will be using is called
<a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">Bash</a>.</p>
<p>Bash is an acronym for the
<em>Bourne Again Shell</em> because it's
based on the original Unix shell
called the Bourne shell,
written by
<a href="https://en.wikipedia.org/wiki/Stephen_R._Bourne">Stephen Bourne</a>.
Bash itself was written by
<a href="https://en.wikipedia.org/wiki/Brian_Fox_(computer_programmer)">Brian Fox</a>.</p>
<p>I think it's important to know
the history of the technologies
that we use, and
Bash has a super interesting
history that pre-exists Linux.
Therefore, I highly encourage you
listen to the
<a href="https://www.redhat.com/en/command-line-heroes">Command Line Heroes</a> episode titled
<a href="https://www.redhat.com/en/command-line-heroes/season-3/heroes-in-a-bash-shell">Heroes in a Bash Shell</a>,
narrated by
<a href="https://saron.io/">Saron Yitbarek</a>.
The episode recounts Brian Fox's
history with the Bash shell
while he worked for the
<a href="https://en.wikipedia.org/wiki/Free_Software_Foundation">Free Software Foundation</a>
in the 1980s.</p>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>We will spend the next few weeks
practicing these commands and
learning the filesystem.
We'll do this because knowing
these things is integral to
accomplishing everything else in this work,
including installing and setting up
our content management systems and
the integrated library system.</p>
<p>In the video for this week,
I'll show you how to install the three
programs that I wrote or modified.
We will use <code>git</code> to download them.
The we will move the programs to a
specific directory in our
executable PATH.
This will allow us to run them
simply by typing their names.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>To install my practice programs,
login to your Linux virtual instances, and
run the following commands.
You will learn more about these commands shortly.</p>
<p>First, let's take a look at the contents
of your home directory
(the default directory you're in when
you connect to your virtual machine):</p>
<pre><code>ls
</code></pre>
<p>Most likely,
nothing will be listed.</p>
<p>Now let's retrieve the programs
using the <code>git</code> command:</p>
<pre><code>git clone https://github.com/cseanburns/learn-the-commandline.git
</code></pre>
<p>Run the <code>ls</code> command again, and
you'll see a new directory called
<code>learn-the-commandline</code>:</p>
<p><code>ls</code></p>
<p>Next, copy the programs to an executable path:</p>
<pre><code>sudo cp learn-the-commandline/* /usr/local/bin
</code></pre>
<p>Run the first program and
work through it in order to learn
some of the basic commands:</p>
<pre><code>learn-the-cli
</code></pre>
<p>When ready,
run the second program in order
to learn about the Linux filesystem:</p>
<pre><code>learn-the-filesystem
</code></pre>
<p>Finally, periodically run the
<code>flashcards</code> program to refresh your
memory of the basic commands, plus
some other commands that you'll learn
about soon:</p>
<pre><code>flashcards
</code></pre>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<p>Dourish, P. (2001). <em>Where the Action Is: The Foundations of
Embodied Interaction</em>. MIT Press.
<a href="https://doi.org/10.7551/mitpress/7221.001.0001">https://doi.org/10.7551/mitpress/7221.001.0001</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-editors"><a class="header" href="#text-editors">Text editors</a></h1>
<p>As we learn more about
how to work on the command line,
we will acquire the need to write
in plain text or edit
configuration files.
Most configuration files for Linux
applications exist
in the <code>/etc</code> directory,
and are regular text files.
For example,
later in the semester
we will install the
<a href="https://httpd.apache.org/">Apache Web Server</a>, and
we will need to edit
Apache's configuration
files in the process.</p>
<p>In order to edit and save text files, 
we need a text editor.
Programmers use text editors
to write programs,
but because programmers 
often work in
graphical user environments,
they may often use 
graphical text editors or graphical
<a href="https://en.wikipedia.org/wiki/Integrated_development_environment">Integrated Development Environments (IDEs)</a>. 
It might be that if you work
in systems librarianship,
that you will often use
a graphical text editor,
but knowing something about
how to use command line-based
editors can be helpful.</p>
<h2 id="what-is-a-plain-text"><a class="header" href="#what-is-a-plain-text">What is a Plain Text?</a></h2>
<p>Plain text is the most basic
way to store human-readable textual information.
Whenever we use a word processor program,
like Microsoft Office,
we are creating a complex series
of files that instruct the Office application
how to display the contents of the file as
well as how the contents are formatted
and arranged.
This can easily be illustrated by
using an archive manager to extract
the contents of a <strong>.docx</strong> file.
Upon examination,
most of the files in a single <strong>.docx</strong>
file are plain text that are
marked up in XML.
The files are packaged as a <strong>.docx</strong>
file and then rendered by an application,
commonly Microsoft Word,
but any application
that can read <strong>.docx</strong> files will do.</p>
<p>A plain text file only contains
<a href="https://www.rapidtables.com/code/text/ascii-table.html">plain text</a>.
Its only arrangement is from top
to bottom.
It does not allow for any kind of
additional formatting,
and it does not include media.
It is the closest thing the digital
has to output produced by a typewriter, but
a <a href="https://www.youtube.com/watch?v=jxkygWI-Wfs">typewriter that's connected to the internet</a>.</p>
<p>A lot of content is written in plain text.
For example, HTML is written in plain text
and the web browser uses the HTML markup to
render how a page will look.</p>
<pre><code>&lt;p&gt;This is using a HTML paragraph tag.
The web browser would normally render this like
the other paragraphs on this page.
However, it's written in a code block,
which allows us to display the HTML tags
and appear as if it's real source code.&lt;/p&gt;
</code></pre>
<p>The rendered result is not plain text but HTML,
just like the rendered result of all those
XML files in a <strong>.docx</strong> file are not
plain text but a <strong>.docx</strong> file.
Softare is written in plain text files
because programming languages cannot
evaluate content that is not just text.
Those of you who have learned how to
use the R programming language wrote
your R code in plain text likely using
the RStudio IDE.
For our purposes,
we need plain text files to
modify configuration files for
the various programs that we will
install later.</p>
<h2 id="why-edit-in-plain-text"><a class="header" href="#why-edit-in-plain-text">Why Edit in Plain Text</a></h2>
<p>Most of the time when we configure software,
we might do it, for example,
by using our mouse to find the settings
menu in some application that we are using.
All that does, for the most part,
is make changes to some text file somewhere.
We will have to be more direct since
we are working on the command line only.
That is, the kind of settings configurations we
will do will require editing a variety
of plain text files that the programs
will use to modify how they work.
Often the settings for programs can only
be modified by editing their plain text
configuration files.</p>
<p>We will also soon be working with Git and GitHub.
These will also require us to use plain text.
More on that in a couple of chapters.</p>
<h2 id="nano"><a class="header" href="#nano"><code>nano</code></a></h2>
<p>The <a href="https://www.nano-editor.org/"><code>nano</code></a> text editor
is one of the user-friendliest
of the text editors available on
the Linux command line, but
it still requires some adjustment
as a new command line user.
The friendliest thing about
<code>nano</code> is that it is modeless,
which is what you're
already accustomed to using.
This means <code>nano</code> can be used
to enter and manipulate text
without changing to
insert or command mode.
It is also friendly because,
like many graphical text editors
and software,
it uses control keys
to perform its operations.</p>
<blockquote>
<p>A modal text editor has modes such as insert mode or
command mode. In insert mode, the user types text as
anyone would in any kind of editor or word processor. The
user switches to command mode to perform operations on the
text, such as find and replace, saving, cutting and
pasting but cannot insert text as they would in insert
mode. Switching between modes usually involves pressing
some specific keys. In Vim and ed(1), my text editors of
choice, the user starts in command mode and switches to
insert mode by pressing the letter <strong>i</strong> or the letter
<strong>a</strong>. The user may switch back to command mode by
pressing the <strong>Esc</strong> key in Vim or by pressing the period
in a new line in ed(1).</p>
</blockquote>
<p>The tricky part to learning <code>nano</code> is that
the control keys are assigned
to different keystroke combinations
than what
many graphical editors
(or word processors) use
by convention today.
For example,
instead of Ctrl-c or Cmd-c to copy text,
in <code>nano</code> you press the <code>M-6</code> key
(press <code>Alt, Cmd, or Esc key</code>
and <code>6</code>) to copy.
Then to paste,
you press <code>Ctrl-u</code> instead
of the more common <code>Ctrl-v</code>.
Fortunately, <code>nano</code> lists
the shortcuts at the bottom
of the screen.</p>
<p>The shortcuts listed
need some explanation, though.
The carat mark is shorthand
for the keyboard's <strong>Control (Ctrl)</strong> key.
Therefore to <strong>Save As</strong> a file,
we <strong>write</strong> out the file
by pressing <code>Ctrl-o</code>
(although <code>Ctrl-s</code> will work, too).
The <strong>M-</strong> key is also important,
and depending on your keyboard
configuration,
it may correspond to your
<code>Alt, Cmd, or Esc</code> keys.
To search for text,
you press <code>^W</code>,
If your goal is to copy,
then press <strong>M-6</strong>
to copy a line.
Move to where you want
to paste the text,
and press <strong>Ctrl-u</strong>
to paste.</p>
<p>We can start <code>nano</code> simply
by typing <code>nano</code> on the command line.
This will open a new, unsaved file
with no content.
Alternatively, we can start <code>nano</code>
by specifying a file name after typing <code>nano</code>.
For example, if I want to open a file
called <strong>example.txt</strong>,
then I type the following command:</p>
<pre><code>nano example.txt
</code></pre>
<p>If the file doesn't exist,
this will create it.
If it does exit, then
the above command will open it.</p>
<p>One of the other tricky things about <code>nano</code>
is that the <em>menu bar</em>
(really just a crib sheet, so to speak)
is at the bottom of
the screen instead of at the top,
which is where we are mostly accustomed to
finding it these days.
Also, the <code>nano</code> program does not provide
pop up dialog boxes.
Instead, all messages from <code>nano</code>,
like what to name a file when we save it,
appear at the bottom of the screen.</p>
<p>Lastly, <code>nano</code> also uses distinct terminology
for some of its functions.
The most important function to remember
is the <strong>Write Out</strong> function,
which means to save.</p>
<p>For the purposes of this class,
that's all you really
need to know about <code>nano</code>.
Use it and get comfortable writing in it.
Some quick tips:</p>
<ol>
<li><code>nano file.txt</code> will open and display the file named <strong>file.txt</strong>.</li>
<li><code>nano</code> by itself will open to an empty page.</li>
<li>Save a file by pressing <code>Ctrl-o</code>.</li>
<li>Quit and save by pressing <code>Ctrl-x</code>.</li>
<li>Be sure to follow the prompts at the bottom of the screen.</li>
</ol>
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>In the prior lesson,
we learned how to use the
Bash interactive shell.
We will continue to do that,
but in the meantime,
in this lesson,
we begin to learn how to use
a command line text editor, <code>nano</code>.
We will use <code>nano</code> to edit
configuration files and publish
text to GitHub.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="searching-with-grep"><a class="header" href="#searching-with-grep">Searching with grep</a></h1>
<p>We have available some powerful utilities and programs
to process, manipulate, and analyze text files.
In this section, we will focus on the <code>grep</code> utility,
which offers some advanced methods for searching
the contents of text files.</p>
<h2 id="grep"><a class="header" href="#grep">Grep</a></h2>
<p>The <code>grep</code> command is one of my most often used commands.
Basically, <code>grep</code> &quot;prints lines that match patterns&quot;
(see <code>man grep</code>).
In other words, it's search, and
it's super powerful.</p>
<p><code>grep</code> works line by line.
So when we use it to search a file for a <strong>string</strong> of text,
it will return the whole line that matches the string.
This <strong>line by line</strong> idea is part of the history of
Unix-like operating systems,
and it's important to remember that most utilities
and programs that we use on the commandline
are line oriented.</p>
<blockquote>
<p>&quot;A string is any series of characters that are interpreted
literally by a script. For example, 'hello world' and 'LKJH019283'
are both examples of strings.&quot; -- <a href="https://www.computerhope.com/jargon/s/string.htm">Computer Hope</a>.
More generally, it's the literal characters that we type. It's data.</p>
</blockquote>
<p>To visualize how <code>grep</code> works,
let's consider a file called
<strong>operating-systems.csv</strong> with content
as seen below:</p>
<pre><code>OS, License, Year
Chrome OS, Proprietary, 2009
FreeBSD, BSD, 1993
Linux, GPL, 1991
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<p>We can use <code>grep</code> to search for anything
in that file.
Let's start with a search for the string <strong>Chrome</strong>.
Notice that even though the string <strong>Chrome</strong> only appears once,
and in one part of a line,
<code>grep</code> returns the entire line.</p>
<p><strong>Command:</strong></p>
<pre><code>grep &quot;Chrome&quot; operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Chrome OS, Proprietary, 2009
</code></pre>
<p>Be aware that, by default, <code>grep</code> is case-sensitive,
which means a search for the string <strong>chrome</strong>,
with a lower case <strong>c</strong>,
would return no results.
Fortunately, <code>grep</code> has an <code>-i</code> option,
which means to ignore the case of the search string.
In the following examples,
<code>grep</code> returns nothing in the first search
since we do not capitalize the string <strong>chrome</strong>.
However, adding the <code>-i</code> option results in success:</p>
<p><strong>Command:</strong></p>
<pre><code>grep &quot;chrome&quot; operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<p>None.</p>
<p><strong>Command:</strong></p>
<pre><code>grep -i &quot;chrome&quot; operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Chrome OS, Proprietary, 2009
</code></pre>
<p>We can also search for lines
that <strong>do not</strong> match our string 
using the <code>-v</code> option.
We can combine that with the <code>-i</code>
option to ignore the string's case.
Therefore, in the following example,
all lines that do not contain the
string <strong>chrome</strong> are returned:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -vi &quot;chrome&quot; operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>FreeBSD, BSD, 1993
Linux, GPL, 1991
iOS, Proprietary, 2007
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<p>Sometimes data files,
like spreadsheets,
contain header columns in the
first row.
We can use <code>grep</code> to remove
the first line of a file by
inverting our search and select
all lines not matching
&quot;OS&quot; at the start of a line.
Here the carat key <code>^</code> is
a <strong>regex</strong> indicating the
start of a line.
Again, this <code>grep</code> command returns
all lines that do not match the
string <strong>os</strong> at the start of a line,
ignoring case:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -vi &quot;^os&quot; operating-systems.csv
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>Chrome OS, Proprietary, 2009
FreeBSD, BSD, 1993
Linux, GPL, 1991
iOS, Proprietary, 2007
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<p>Alternatively, since we know that
the string <strong>Year</strong> comes
at the end of the first line,
we can use <code>grep</code> to invert search for that.
Here the dollar sign key <code>$</code>
is a <strong>regex</strong> indicating the
end of a line.
Like the above,
this <code>grep</code> command returns all lines that
do not match the string <strong>year</strong>
at the end of a line,
ignoring case.
The result,
in this specific instance,
is exactly the same as the last command:</p>
<p><strong>Command</strong>:</p>
<pre><code>grep -vi &quot;year$&quot; operating-systems.csv
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>Chrome OS, Proprietary, 2009
FreeBSD, BSD, 1993
Linux, GPL, 1991
iOS, Proprietary, 2007
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<p>The <code>man grep</code> page lists other options,
but a couple of other good ones include:</p>
<p>Get a count of the matching lines with the <code>-c</code> option:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -ic &quot;proprietary&quot; operating-systems.csv
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>4
</code></pre>
<p>Print only the match and
not the whole line with the <code>-o</code> option:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -io &quot;proprietary&quot; operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Proprietary
Proprietary
Proprietary
Proprietary
</code></pre>
<p>We can simulate a Boolean OR search, and
print lines matching one or both strings
using the <code>-E</code> option.
We separate the strings with a vertical bar <code>|</code>.
This is similar to a Boolean OR search
since there's at least one match in the following string,
there is at least one result.</p>
<p>Here is an example where only one string
returns a true value:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -Ei &quot;(bsd|atari)&quot; operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>FreeBSD, BSD, 1993
</code></pre>
<p>Here's an example where both strings evaluate to true:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -Ei &quot;(bsd|gpl)&quot; operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>FreeBSD, BSD, 1993
Linux, GPL, 1991
</code></pre>
<p>By default, <code>grep</code> will return results where the
string appears within a larger word,
like <strong>OS</strong> in <strong>macOS</strong>.</p>
<p><strong>Command:</strong></p>
<pre><code>grep -i &quot;os&quot; operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>OS, License, Year
Chrome OS, Proprietary, 2009
iOS, Proprietary, 2007
macOS, Proprietary, 2001
</code></pre>
<p>However, we might want to limit results so that
we only return results where <strong>OS</strong> is a complete word.
To do that, we can surround the string with
special characters:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -i &quot;\&lt;os\&gt;&quot; operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>OS, License, Year
Chrome OS, Proprietary, 2009
</code></pre>
<p>Sometimes I find it hard to remember
the backslash and angle bracket combinations
because they're too much alike HTML syntax but
not exactly like HTML syntax.
Fortunately, <code>grep</code> has a <code>-w</code> option
to match whole words:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -wi &quot;os&quot; operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>OS, License, Year
Chrome OS, Proprietary, 2009
</code></pre>
<p>Sometimes we want the context for a result;
that is,
we might want to print lines that surround our matches.
For example, print the matching line plus the two lines
after the matching line using the <code>-A NUM</code> option:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -i &quot;linux&quot; -A2 operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Linux, GPL, 1991
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
</code></pre>
<p>Or, print the matching line plus the two lines
before the matching line using the <code>-B NUM</code> option:</p>
<p><strong>Command</strong></p>
<pre><code>grep -i &quot;linux&quot; -B2 operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Chrome OS, Proprietary, 2009
FreeBSD, BSD, 1993
Linux, GPL, 1991

</code></pre>
<p>We can combine many of the variations.
Here I search for the whole word <strong>BSD</strong>,
case insensitive, and
print the line before and the line after
the match:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -iw -C1 &quot;bsd&quot; operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Chrome OS, Proprietary, 2009
FreeBSD, BSD, 1993
Linux, GPL, 1991
</code></pre>
<p>We can use another option to
stop returning results after some
number of hits.
Here I use <code>grep</code> to return
search for the string &quot;proprietary&quot;
and stop after the first hit:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -i -m1 &quot;proprietary&quot; operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Chrome OS, Proprietary, 2009
</code></pre>
<p>We can add the <code>-n</code> option to
instruct <code>grep</code> to tell us what
line number for each hit.
Below we see that the string
&quot;proprietary&quot; is found on lines
2, 5, and 6.</p>
<p><strong>Command:</strong></p>
<pre><code>grep -in &quot;proprietary&quot; operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>2:Chrome OS, Proprietary, 2009
5:macOS, Proprietary, 2001
6:Windows NT, Proprietary, 1993
</code></pre>
<p>We can use <code>grep</code> to search for
patterns in strings instead of literal words.
Here we use what's called <strong>character classes</strong>
and <strong>repetition</strong> to search for five letter words:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -Eiw &quot;[a-z]{5}&quot; operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Linux, GPL, 1991
macOS, Proprietary, 2001
</code></pre>
<p>Or four letter numbers:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -Eiw &quot;[0-9]{4}&quot; operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Chrome OS, Proprietary, 2009
FreeBSD, BSD, 1993
Linux, GPL, 1991
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<p><code>grep</code> can also search for words that
begin with some letter and end with some letter
and with a specified number of letters between.
Here we search for words that start with <strong>m</strong>,
end with <strong>s</strong>, and have three letters in the middle:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -Eiw &quot;m.{3}s&quot; operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>macOS, Proprietary, 2001
</code></pre>
<h2 id="practice"><a class="header" href="#practice">Practice</a></h2>
<p>Here let's practice looking at the <strong>auth.log</strong> file.
This file records all attempts to login to the system:</p>
<p>First, we change directory to <code>/var/log</code>.</p>
<p>Second, we use <code>less</code> to peruse the <strong>auth.log</strong> file.</p>
<p>Third, we do a simple <code>grep</code> search for the string
<strong>invalid user</strong> and
pipe that through another grep command
that examines IP addresses.</p>
<p>Fourth, we do another simple search for a longer
string and pipe that through other commands to
sort the data.</p>
<pre><code>cd /var/log
less auth.log
grep -E &quot;session opened for user (sean|root)&quot; auth.log | less
grep &quot;invalid user&quot; auth.log | grep -Eo &quot;[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}&quot; | sort | uniq -c | sort
grep &quot;Connection closed by invalid user&quot; auth.log | cut -d&quot; &quot; -f11 | sort | uniq -c | sort |less
grep &quot;Connection closed by invalid user&quot; auth.log | cut -d&quot; &quot; -f11 | sort | uniq -c | sort -r |less
</code></pre>
<h2 id="conclusion-5"><a class="header" href="#conclusion-5">Conclusion</a></h2>
<p><code>grep</code> is very powerful, and
there are more options listed in its <code>man</code> page.</p>
<blockquote>
<p>Note that I enclose my search strings in double quotes.
For example: <code>grep &quot;search string&quot; filename.txt</code>
It's not always required to enclose a search string
in double quotes,
but it's good practice because
if your string contains more than one word or
empty spaces, the search will fail.</p>
</blockquote>
<p>The Linux (and other Unix-like OSes) command line
offers a lot of utilities to examine data.
It's fun to learn and practice these.
Despite this, you do not have to become
an advanced <code>grep</code> user.
For most cases,
simple <code>grep</code> searches work well.</p>
<p>If you want to learn more,
there are many <code>grep</code> tutorials on the web.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-software"><a class="header" href="#managing-software">Managing Software</a></h1>
<h2 id="introduction-4"><a class="header" href="#introduction-4">Introduction</a></h2>
<p>Most Linux distributions use
what's called a <strong>package manager</strong> to
handle the installation, upgrades, and
uninstalls of the software on a system.
The Ubuntu distribution uses a
package manager called <code>dpkg</code> and
a front-end called <code>apt</code>
(advanced package tool).
We will use <code>apt</code> to install,
update, and remove software
from our servers.</p>
<h2 id="sudo"><a class="header" href="#sudo"><code>sudo</code></a></h2>
<p>In order to do the above tasks,
we will need to use
the <code>sudo</code> command.
The <code>sudo</code> command allows us to
&quot;execute a command as another user&quot;
(see <code>man sudo</code>).
If we have multiple users on a system,
and if we have their passwords,
then we could use <code>sudo</code> to run
commands as if we were logged into
their accounts.</p>
<p>However, the main use of <code>sudo</code>
is to execute a command as the <strong>root</strong> user.
The root user is the <strong>superuser</strong> account
and as such,
this user can perform administrative tasks
that regular users cannot.
For security purposes,
regular accounts may not add, remove, or
update software on a system, nor
may they modify most files or directories
outside their home directories.
Using <code>sudo</code> allows regular users to
perform maintenance tasks on our systems
by executing commands as the root user.
Some consider this safer than logging
in as the root user.</p>
<p>Not all regular users can use
the <code>sudo</code> command.
On regular Ubuntu distributions,
users must belong to the <strong>sudo</strong> group
in order to run the <code>sudo</code> command.
The <code>groups</code> command will return
a list of groups that your account belongs to.
On the Ubuntu version used by the
Google Cloud Platform (GCP),
the group of interest is called <strong>google-sudoers</strong>.
The difference between the <strong>sudo</strong> group
on regular Ubuntu distributions and
the GCP version is that regular users in the
<strong>google-sudoers</strong> group are not prompted for
their password.</p>
<p>Down the line,
we will need to use the <code>sudo</code> command
to modify files, create directories, and
perform other maintenance tasks needed to
install and manage software.
In this lesson, we will use <code>sudo</code> along
with the <code>apt</code> commands to update our
systems and install software.</p>
<h3 id="sudo-syntax"><a class="header" href="#sudo-syntax"><code>sudo</code> syntax</a></h3>
<p>The <code>sudo</code> command is simple to use.
When necessary,
we use <code>sudo</code> by pre-pending it to
the regular commands that we have already
learned.
In our home directories, for example,
we don't need to use <code>sudo</code> to
create a new directory with the <code>mkdir</code>
command.
Instead we just type
<code>mkdir data</code> to create a new
directory/folder called <strong>data</strong>.
But outside our home directory,
for example, in the directory
<strong>/usr/local/bin</strong>.
We need to use <code>sudo</code> to do such things.
(This is why I used the <code>sudo</code> command
when I showed you how to copy the
<strong>Learn the Commandline</strong> programs to
<strong>/usr/local/bin</strong>.)
If I want to create a <strong>data</strong> directory
in <strong>/usr/local/bin</strong>, then
I have to use sudo at the beginning of
my command:</p>
<pre><code>cd /usr/local/bin
sudo mkdir data
</code></pre>
<p>Or, without changing to that directory,
I can just specify the full path:</p>
<pre><code>sudo mkdir /usr/local/bin/data
</code></pre>
<p>Or if I want to create a file in
some other directory outside my
home directory, then
I have to use sudo there, too:</p>
<pre><code>cd /etc
sudo touch data.csv
</code></pre>
<p>Or, without changing to that directory,
I can specify the full path:</p>
<pre><code>sudo touch /etc/data.csv
</code></pre>
<h2 id="apt"><a class="header" href="#apt">apt</a></h2>
<p>We will use <code>sudo</code> in the above
ways soon enough, but for now,
we will use <code>sudo</code> to install,
update, and uninstall software on
our systems.</p>
<p>Next I'll demonstrate the <code>apt</code>
commands that we'll need.</p>
<h3 id="sudo-apt-update"><a class="header" href="#sudo-apt-update"><code>sudo apt update</code></a></h3>
<p>Your system keeps a record of
what software is installed on your
system and their version numbers.
The <code>sudo apt update</code> command
updates that list and compares
the update to what's installed.
That is, if you have a piece of
software called <strong>acme1.1</strong> on your system,
and <strong>acme1.2</strong> is available, then
running <code>sudo apt update</code> will
let you know that you can upgrade to
<strong>acme1.2</strong>.
It's good practice to run <code>sudo apt update</code>
before installing or upgrading your system
because this lets your system upgrade to
the most recent version of what you want
to install.</p>
<p>In short, this command is simply:</p>
<pre><code>sudo apt update
</code></pre>
<h3 id="sudo-apt-upgrade"><a class="header" href="#sudo-apt-upgrade"><code>sudo apt upgrade</code></a></h3>
<p>Once your list of software has been updated,
you can <strong>upgrade</strong> with the <code>sudo apt upgrade</code>
command if there are any upgrades.
When you run this command, and if
there are any upgrades,
you will be prompted to proceed.
You can press <strong>Y</strong> to proceed, or
<strong>N</strong> to cancel.</p>
<p>This command is simply:</p>
<pre><code>sudo apt upgrade
</code></pre>
<h3 id="apt-search"><a class="header" href="#apt-search"><code>apt search</code></a></h3>
<p>If you want to install a piece
of software, then
you have to install it using its
package name.
Sometimes that means we have to
search for the name of the package.
This is one of the <code>apt</code> commands
that does not require the use of <code>sudo</code>.
<code>sudo</code> is not required because
<code>apt search</code> does not modify the system.
It simply helps you search for a package name.</p>
<p>For example, the <code>man</code> pages provide
helpful documentation about how to use
the commands on our systems, but
the <code>man</code> pages can also be dense and
not straightforward.</p>
<p>Fortunately, there's an application called
<code>tldr</code> that is a community-driven application
that provides simple help pages and examples
of how to use some of the most commonly used
commands.</p>
<p>To search for the <code>tldr</code> package,
we execute the following command:</p>
<pre><code>apt search tldr
</code></pre>
<p>This returns a list of results that
match the search query.
One of those results is the <code>tldr</code> package,
which is simply named <strong>tldr</strong>.
Not all packages are simply named,
which is why we need to search for the
specific name.</p>
<blockquote>
<p>Note that sometimes when we search for a package, the list
of results is quite long. In those cases, pipe the above
command through the <code>less</code> pager to page through the
results: <code>apt search &lt;packagename&gt; | less</code></p>
</blockquote>
<h2 id="apt-show"><a class="header" href="#apt-show"><code>apt show</code></a></h2>
<p>If we want more specific information
about the package,
we can use the <code>apt show</code> command
along with the package name.
Therefore, to get more information
about the <code>tldr</code> application,
we execute the following command:</p>
<pre><code>apt show tldr
</code></pre>
<p>This will return a fuller description
of the package (usually), as well
as the URL to the application's website,
plus other details.
We do not need to use <code>sudo</code> here
because we are not modifying the system.
We are only retrieving information.</p>
<h2 id="sudo-apt-install"><a class="header" href="#sudo-apt-install"><code>sudo apt install</code></a></h2>
<p>To install the <code>tldr</code> application,
we use the <code>sudo apt install</code> command
along with the package name.
We want to make sure that the name of the
package is exactly what was returned from
the <code>apt search</code> command.
In the <code>tldr</code> case,
it's pretty straightforward, and to install:</p>
<pre><code>sudo apt install tldr
</code></pre>
<h2 id="sudo-apt-remove"><a class="header" href="#sudo-apt-remove"><code>sudo apt remove</code></a></h2>
<p>In order to remove a package,
we use the <code>sudo apt remove</code>
command.
I like to add the <code>--purge</code> option
because this also removes system configuration
files that I probably do not need.
That is, some applications
install configuration files (configs).
Configs are files that set application preferences
in the <strong>/etc</strong> directory.
Adding <code>--purge</code> will remove those configs.</p>
<p>To remove a package and
its system configuration files (if any),
we run the above command with the package name.</p>
<pre><code>sudo apt --purge remove tldr
</code></pre>
<p>Some configs are stored in your home directory.
Generally only end user applications install
configs in our home directories.
The <code>--purge</code> option will not remove those configs;
instead, we have to remove them manually if we want.</p>
<h3 id="sudo-apt-autoremove"><a class="header" href="#sudo-apt-autoremove"><code>sudo apt autoremove</code></a></h3>
<p>One of the great things about <code>dpkg</code> and <code>apt</code>
is that it installs and handles software
<strong>dependencies</strong> really well.
Dependencies are other software that software
depends upon to run.
That is, few computer applications are self-contained, and
they often require other technology.
When we uninstall (or remove) applications,
the package manager does not auto uninstall those
dependencies that were installed with it.
We use the autoremove command to uninstall those:</p>
<pre><code>sudo apt autoremove
</code></pre>
<h3 id="sudo-apt-clean"><a class="header" href="#sudo-apt-clean"><code>sudo apt clean</code></a></h3>
<p>When we install packages,
some files are installed with them.
The <code>sudo apt clean</code> removes those
extra files and frees up disk space.
It's a simple command:</p>
<pre><code>sudo apt clean
</code></pre>
<h2 id="conclusion-6"><a class="header" href="#conclusion-6">Conclusion</a></h2>
<p>The <code>apt</code> command makes it quite easy
to manage software on our systems.
We will use this command to install more
complicated software later.
Here's a list of commands we covered:</p>
<ul>
<li><code>sudo apt update</code></li>
<li><code>sudo apt upgrade</code></li>
<li><code>apt search</code></li>
<li><code>apt show</code></li>
<li><code>sudo apt install</code></li>
<li><code>sudo apt --purge remove</code></li>
<li><code>sudo apt autoremove</code></li>
<li><code>sudo apt clean</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="install-the-koha-ils"><a class="header" href="#install-the-koha-ils">Install the Koha ILS</a></h1>
<p>Preliminary notes on setting up <a href="https://koha-community.org/">Koha ILS</a> on Google Cloud.</p>
<p>Helpful documentation and demos:</p>
<ul>
<li><a href="https://wiki.koha-community.org/wiki/Koha_on_Debian">Koha on Debian</a></li>
<li><a href="https://www.youtube.com/watch?v=mzUop9R4sKc">Install Koha on Google Cloud Platform</a></li>
</ul>
<h2 id="pre-setup"><a class="header" href="#pre-setup">Pre-setup</a></h2>
<pre><code>apt-get update
apt-get upgrade
apt-get autoremove -y 
apt-get install gnupg2
</code></pre>
<h2 id="prep-koha"><a class="header" href="#prep-koha">Prep Koha</a></h2>
<p>Add Koha to repos:</p>
<pre><code>echo 'deb http://debian.koha-community.org/koha stable main' | sudo tee /etc/apt/sources.list.d/koha.list
</code></pre>
<p>Use the first one but listing the second just in case:</p>
<pre><code>wget -qO - https://debian.koha-community.org/koha/gpg.asc | gpg --dearmor -o /usr/share/keyrings/koha-keyring.gpg
#wget -q -O- https://debian.koha-community.org/koha/gpg.asc | sudo apt-key add -
</code></pre>
<h2 id="install-koha"><a class="header" href="#install-koha">Install Koha:</a></h2>
<pre><code>apt-get update
apt-get install koha-common
nano /etc/koha/koha-sites.conf
# add:
# INTRAPORT=&quot;8080&quot;
sudo apt-get install mysql-server
mysqladmin -u root password bibliolib1
a2enmod rewrite
a2enmod cgi 
systemctl restart apache2
koha-create --create-db bibliolib
nano /etc/apache2/ports.conf 
# add:
# Listen: 8080
systemctl restart apache2
a2dissite 000-default
a2enmod deflate
a2ensite bibliolib
systemctl reload apache2
systemctl restart apache2
</code></pre>
<h2 id="get-username-and-password"><a class="header" href="#get-username-and-password">Get username and password</a></h2>
<pre><code>nano /etc/koha/sites/bibliolib/koha-conf.xml
</code></pre>
<h2 id="run-the-web-installer-at"><a class="header" href="#run-the-web-installer-at">Run the web installer at:</a></h2>
<p>Be sure to follow instructions.</p>
<pre><code>http://IP-ADDRESS:8080
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>

        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
